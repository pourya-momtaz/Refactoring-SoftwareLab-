# Refactoring-SoftwareLab
<div style="text-align: right"> 
  

  <br>
  <par style="text-align: right">
بخش اول (Abstract Factory):ابتدا پروژه ساده‌ای با maven ساختم که ساختار فایل pom در تصویر زیر قابل مشاهده است و به سراغ پیاده سازی abstract factory رفته‌ام. این الگو یک الگوی creational است که یک رابط برای ایجاد خانواده‌های اشیاء مرتبط بدون مشخص کردن کلاس‌های مشخص آنها فراهم می‌کند. در این الگو یک رابط کارخانه انتزاعی تعریف می‌کنیم که روش‌هایی را برای ایجاد انواع مختلف اشیاء اعلام می‌کند و سپس کلاس‌های کارخانه‌ای مشخصی ایجاد می‌کند که رابط را پیاده‌سازی کرده و اشیاء خاص را ایجاد می‌کند. سپس اول تست‌های مربوطه را نوشتم که در تصویر زیر مشاهده می‌کنید.
  </par>
    <br>
  سپس کلاس‌هایی که در تصاویر زیر می‌بینید را پیاده کردم و در نهایت تست را ران کرده‌ام. از آوردن عکس تک تک مراحل تست خودداری کرده‌ام و مراحل مانند آزمایش‌های گذشته انجام شده‎‌اند. در این پروژه یک سازندۀ باغ داریم که دو نوع باغ ژاپنی و ایرانی را تولید می‌کند و دو نوع درخت و گل ایرانی و ژاپنی هم داریم که بسته به نوع سازندۀ باغ، از یکی از آنها استفاده می‌شود. خود سازندۀ باغ، درخت و گل، کلاس‌های abstract هستند اما فرزندان آنها، concrete هستند و هر کدام، پدر را implement کرده‌اند.
  <br>
  

  <br>
دربخش دوم (Prototype): بخش بعد، prototype را پیاده کرده‌ام که یک الگوی طراحی creational است که امکان شبیه سازی یا کپی کردن اشیاء را فراهم می کند. ایده این است که یک شی نمونه اولیه ایجاد کنیم و سپس با شبیه سازی نمونه اولیه، اشیاء جدید ایجاد کنیم. این الگو، زمانی مفید است که ایجاد اشیاء هزینه بر است یا می‌خواهیم اشیاء جدیدی ایجاد کنیم که مشابه اشیاء موجود هستند. در تصاویر زیر، ابتدا تست را مشاهده می‌کنید و سپس پیاده سازی کلاس‌ها و در نهایت نتیجه تست را می‌توانید ببینید. ابتدا رابط Prototype را تعریف کردم که دو روش دارد: getDescription() و clone(). متدgetDescription ()  شرحی از نمونه اولیه را برمی‌گرداند و متد ()clone یک شی جدید ایجاد می‌کند که یک کپی از نمونه اولیه است. سپس دو نمونه اولیه concrete تعریف کردم: ConcretePrototype1 و ConcretePrototype2. هر یک از این کلاس‌ها رابط Prototype را پیاده‌سازی می‌کنند و دارای یک فیلد توضیحات هستند که توصیفی از نمونه اولیه را ذخیره می‌کند. متد ()clone در هر کلاس از متد ()super.clone برای ایجاد یک شی جدید که کپی از نمونه اولیه است استفاده می کند.
 
<br>
  <br>
 بخش سوم (Builder): در بخش بعد، builder را پیاده کرده‌ام که یک الگوی طراحی creational است که از یک شی builder برای ساختن گام به گام شی استفاده کنیم که امکان کنترل بیشتر بر فرآیند ساخت و توانایی ایجاد نمایش های مختلف از یک شی را فراهم می کند. در تصاویر زیر، ابتدا کلاس تست و سپس کلاس‌های دیگر و در نهایت نتیجه تست را می‌توانید مشاهده کنید. ابتدا کلاس Product را تعریف کردم که دارای یک فیلد توضیحات است که توضیحات محصول را ذخیره می کند. کلاس Product همچنین یک متد getDescription()  دارد که توضیحات را برمی گرداند. بعد، رابط Builder را تعریف کردم که دارای سه روش buildPartA()، buildPartB() و buildPartC().  از این روش ها برای ساخت قسمت های مختلف محصول استفاده می شود. رابط Builder همچنین دارای یک متد getResult()  است که محصول نهایی را برمی گرداند. سپس دو سازنده concrete تعریف کردم به نام‌های ConcreteBuilder1 و ConcreteBuilder2.  هر یک از این کلاس ها رابط Builder را پیاده سازی می کنند و یک فیلد محصول دارند که محصول در حال ساخت را ذخیره می کند. متدهای buildPartA()، buildPartB() و buildPartC() در هر کلاس، قسمت های مربوطه را به توضیحات محصول اضافه می کنند. متد getResult()  محصول نهایی را برمی گرداند. در نهایت، کلاس Director را تعریف کردم که دارای یک متد construct()  است که یک شی Builder را می گیرد و از آن برای ساختن محصول گام به گام استفاده می کند.
  <br>
  
  #سوالات
  
  
 سوال اول: 1. code cleaning: فرآیند بهبود کیفیت کدهای موجود با حذف افزونگی‌ها، بازنویسی و بازسازی کد و بهینه‌سازی آن برای عملکرد بهتر است. 
  <br>
  2. technical debt: هزینه ای که یک پروژه نرم افزاری به دلیل استفاده از میانبرها یا trade-off های نا به جا در طول توسعه متحمل می شود، که منجر به انباشته شدن مسائلی می شود که در آینده نیاز به رفع آن هست.
 <br>
  3. bad smell: نشانه ای از کیفیت پایین کد،  و یا یک مشکل بالقوه در کد است که می تواند منجر به خطاها، مشکلات نگهداری یا مشکلات عملکرد شود.
  <br>
  سوال دوم: 1. bloaters: دسته‌ای تز bad smellها هستند که نشان دهنده کد بسیار پیچیده یا کدی است که بیش از حد بزرگ شده و نگهداری آن دشوار است. به عنوان مثال از این دسته می توان به متد طولانی و کلاس بزرگ اشاره کرد.
  <br>
    2. object-orientation abusers: دسته ای bad smell ها هستند که نشان دهنده نقض اصول طراحی شی گرا، مانند اصل مسئولیت منفرد یا اصل باز/بسته است. مثال‌ها عبارتند از استیتمنت‌های سوئیچ، data class، و میراث رد شده.
 <br>
  3. change preventers: دسته‌ای از bad smellها هستند که تغییر یا گسترش هسته کد را دشوار می کنند. به عنوان مثال می توان به تغییر واگرا، جراحی با تفنگ ساچمه ای، و Parallel Inheritance Hierarchies اشاره کرد.
  <br>
  4. dispensables: دسته‌ای از bad smellها هستند که نشان دهنده کدهای غیر ضروری یا اضافی هستند. به عنوان مثال می توان به Dead Code، Speculative Generality و Duplicate Code اشاره کرد.
  <br>
  5. couplers: دسته‌ای از bad smellها هستند که نشان دهنده اتصال تنگاتنگ بین کلاس ها یا ماژول ها است و تغییر یا آزمایش کد را دشوار می کند. به عنوان مثال می توان به Feature Envy، Message Chains و Middle Man اشاره کرد.
  <br>
  سوال سوم: 1. dipensableها
  <br>
  2. استفاده از inline class، روش ادغام کلاس‌ها و Extract Subclass or Extract Interface
  <br>
  3. اگر انتظار دارید که کلاس تنبل در آینده مسئولیت ها یا عملکردهای بیشتری به دست آورد، ممکن است منطقی باشد که آن را به عنوان یک کلاس جداگانه نگه دارید. این امر می تواند گسترش و حفظ بنیان کد را در صورت بروز نیازهای جدید آسان تر کند. در حالت دیگر اگر کلاس تنبل مسئول یک concern یا concept خاص است، ممکن است جدا نگه داشتن آن مفید باشد، حتی اگر عملکرد زیادی نداشته باشد. این می تواند به حفظ تفکیک دقیق نگرانی ها کمک کند و کد را قابل درک تر کند. همچنین گاهی اوقات، یک کلاس تنبل ممکن است برای اهداف آزمایشی مفید باشد. به عنوان مثال، ممکن است هنگام نوشتن تست‌های واحد برای کلاس‌های دیگری که به آن وابسته هستند، mock کردن یا خرد کردن یک کلاس تنبل آسان‌تر باشد. در چنین مواردی، نگه داشتن کلاس تنبل می تواند تست پذیری و نگهداری را بهبود بخشد.
  
</div>
