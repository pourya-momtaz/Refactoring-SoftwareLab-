# Refactoring-SoftwareLab
<div style="text-align: right"> 
  

  <br>
  <par style="text-align: right">
بخش اول (Abstract Factory):ابتدا پروژه ساده‌ای با maven ساختم که ساختار فایل pom در تصویر زیر قابل مشاهده است و به سراغ پیاده سازی abstract factory رفته‌ام. این الگو یک الگوی creational است که یک رابط برای ایجاد خانواده‌های اشیاء مرتبط بدون مشخص کردن کلاس‌های مشخص آنها فراهم می‌کند. در این الگو یک رابط کارخانه انتزاعی تعریف می‌کنیم که روش‌هایی را برای ایجاد انواع مختلف اشیاء اعلام می‌کند و سپس کلاس‌های کارخانه‌ای مشخصی ایجاد می‌کند که رابط را پیاده‌سازی کرده و اشیاء خاص را ایجاد می‌کند. سپس اول تست‌های مربوطه را نوشتم که در تصویر زیر مشاهده می‌کنید.
  </par>
    <br>
  سپس کلاس‌هایی که در تصاویر زیر می‌بینید را پیاده کردم و در نهایت تست را ران کرده‌ام. از آوردن عکس تک تک مراحل تست خودداری کرده‌ام و مراحل مانند آزمایش‌های گذشته انجام شده‎‌اند. در این پروژه یک سازندۀ باغ داریم که دو نوع باغ ژاپنی و ایرانی را تولید می‌کند و دو نوع درخت و گل ایرانی و ژاپنی هم داریم که بسته به نوع سازندۀ باغ، از یکی از آنها استفاده می‌شود. خود سازندۀ باغ، درخت و گل، کلاس‌های abstract هستند اما فرزندان آنها، concrete هستند و هر کدام، پدر را implement کرده‌اند.
  <br>
  

  <br>
دربخش دوم (Prototype): بخش بعد، prototype را پیاده کرده‌ام که یک الگوی طراحی creational است که امکان شبیه سازی یا کپی کردن اشیاء را فراهم می کند. ایده این است که یک شی نمونه اولیه ایجاد کنیم و سپس با شبیه سازی نمونه اولیه، اشیاء جدید ایجاد کنیم. این الگو، زمانی مفید است که ایجاد اشیاء هزینه بر است یا می‌خواهیم اشیاء جدیدی ایجاد کنیم که مشابه اشیاء موجود هستند. در تصاویر زیر، ابتدا تست را مشاهده می‌کنید و سپس پیاده سازی کلاس‌ها و در نهایت نتیجه تست را می‌توانید ببینید. ابتدا رابط Prototype را تعریف کردم که دو روش دارد: getDescription() و clone(). متدgetDescription ()  شرحی از نمونه اولیه را برمی‌گرداند و متد ()clone یک شی جدید ایجاد می‌کند که یک کپی از نمونه اولیه است. سپس دو نمونه اولیه concrete تعریف کردم: ConcretePrototype1 و ConcretePrototype2. هر یک از این کلاس‌ها رابط Prototype را پیاده‌سازی می‌کنند و دارای یک فیلد توضیحات هستند که توصیفی از نمونه اولیه را ذخیره می‌کند. متد ()clone در هر کلاس از متد ()super.clone برای ایجاد یک شی جدید که کپی از نمونه اولیه است استفاده می کند.
 
<br>
  <br>
 بخش سوم (Builder): در بخش بعد، builder را پیاده کرده‌ام که یک الگوی طراحی creational است که از یک شی builder برای ساختن گام به گام شی استفاده کنیم که امکان کنترل بیشتر بر فرآیند ساخت و توانایی ایجاد نمایش های مختلف از یک شی را فراهم می کند. در تصاویر زیر، ابتدا کلاس تست و سپس کلاس‌های دیگر و در نهایت نتیجه تست را می‌توانید مشاهده کنید. ابتدا کلاس Product را تعریف کردم که دارای یک فیلد توضیحات است که توضیحات محصول را ذخیره می کند. کلاس Product همچنین یک متد getDescription()  دارد که توضیحات را برمی گرداند. بعد، رابط Builder را تعریف کردم که دارای سه روش buildPartA()، buildPartB() و buildPartC().  از این روش ها برای ساخت قسمت های مختلف محصول استفاده می شود. رابط Builder همچنین دارای یک متد getResult()  است که محصول نهایی را برمی گرداند. سپس دو سازنده concrete تعریف کردم به نام‌های ConcreteBuilder1 و ConcreteBuilder2.  هر یک از این کلاس ها رابط Builder را پیاده سازی می کنند و یک فیلد محصول دارند که محصول در حال ساخت را ذخیره می کند. متدهای buildPartA()، buildPartB() و buildPartC() در هر کلاس، قسمت های مربوطه را به توضیحات محصول اضافه می کنند. متد getResult()  محصول نهایی را برمی گرداند. در نهایت، کلاس Director را تعریف کردم که دارای یک متد construct()  است که یک شی Builder را می گیرد و از آن برای ساختن محصول گام به گام استفاده می کند.
  <br>
  
  #سوالات
  
  
 سوال اول: 1. code cleaning: فرآیند بهبود کیفیت کدهای موجود با حذف افزونگی‌ها، بازنویسی و بازسازی کد و بهینه‌سازی آن برای عملکرد بهتر است. 
  <br>
  2. technical debt: هزینه ای که یک پروژه نرم افزاری به دلیل استفاده از میانبرها یا trade-off های نا به جا در طول توسعه متحمل می شود، که منجر به انباشته شدن مسائلی می شود که در آینده نیاز به رفع آن هست.
 <br>
  3. bad smell: نشانه ای از کیفیت پایین کد،  و یا یک مشکل بالقوه در کد است که می تواند منجر به خطاها، مشکلات نگهداری یا مشکلات عملکرد شود.
  <br>
  سوال دوم: جزو دسته creational هستند
  <br>
  سوال سوم:پنج اصل SOLID (Single Responsibility، Open-Closed، Liskov Substitution، Interface Segregation و Dependency Inversion) دستورالعمل های سطح بالایی برای طراحی نرم افزارهایی هستند که نگهداری، گسترش و اصلاح را آسان می‌کنند. این اصول بر طراحی کلاس‌ها و اجزای منفرد متمرکز شده‌اند و مجموعه‌ای از قوانین را برای ایجاد کلاس‌هایی ارائه می‌کنند که ماژولار، انعطاف‌پذیر و reusable هستند. از سوی دیگر، الگوهای طراحی ارائه شده در GoF راه حل های خاصی برای مشکلات رایج در طراحی نرم افزار هستند. این الگوها بر روابط بین کلاس‌ها و مؤلفه‌ها تمرکز دارند و مجموعه‌ای از راه‌حل‌های اثبات شده را برای ایجاد نرم‌افزاری قوی، مقیاس‌پذیر و قابل نگهداری ارائه می‌دهند. هر الگو یک مشکل خاص را توصیف می کند و راه حلی ارائه می دهد که می تواند با موقعیت های مختلف سازگار شود.
  <br>
  سئال چهارم: اصل مسئولیت واحد (SRP) بیان می کند که یک کلاس باید تنها یک دلیل برای تغییر داشته باشد. در مورد الگوی Singleton، کلاس مسئول ایجاد و مدیریت نمونه واحد کلاس است. این می تواند به عنوان نقض SRP در نظر گرفته شود، زیرا کلاس دو مسئولیت دارد. با این حال، این همیشه یک مشکل نیست، زیرا الگوی Singleton اغلب برای مدیریت یک منبع یا سرویس استفاده می‌شود، و داشتن مسئولیت ایجاد و مدیریت آن منبع در یک کلاس می‌تواند مفید باشد. این تنها موردی است که singleton میتواند نقض کند اما باز میتوان آن را به روشی پیاده کرد لزوماً هیچ یک از اصول SOLID را نقض نکند، اما اجرای آن به روشی که به همه آنها پایبند باشد می تواند دشوار باشد.
  
</div>
