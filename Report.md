# Refactoring-SoftwareLab
<div style="text-align: right"> 
  

  <br>
  <par style="text-align: right">
گزارش در فایل PDF آمده است.
  <br>
  
  #سوالات
  
  
 سوال اول: 1. code cleaning: فرآیند بهبود کیفیت کدهای موجود با حذف افزونگی‌ها، بازنویسی و بازسازی کد و بهینه‌سازی آن برای عملکرد بهتر است. 
  <br>
  2. technical debt: هزینه ای که یک پروژه نرم افزاری به دلیل استفاده از میانبرها یا trade-off های نا به جا در طول توسعه متحمل می شود، که منجر به انباشته شدن مسائلی می شود که در آینده نیاز به رفع آن هست.
 <br>
  3. bad smell: نشانه ای از کیفیت پایین کد،  و یا یک مشکل بالقوه در کد است که می تواند منجر به خطاها، مشکلات نگهداری یا مشکلات عملکرد شود.
  <br>
  سوال دوم: 1. bloaters: دسته‌ای تز bad smellها هستند که نشان دهنده کد بسیار پیچیده یا کدی است که بیش از حد بزرگ شده و نگهداری آن دشوار است. به عنوان مثال از این دسته می توان به متد طولانی و کلاس بزرگ اشاره کرد.
  <br>
    2. object-orientation abusers: دسته ای bad smell ها هستند که نشان دهنده نقض اصول طراحی شی گرا، مانند اصل مسئولیت منفرد یا اصل باز/بسته است. مثال‌ها عبارتند از استیتمنت‌های سوئیچ، data class، و میراث رد شده.
 <br>
  3. change preventers: دسته‌ای از bad smellها هستند که تغییر یا گسترش هسته کد را دشوار می کنند. به عنوان مثال می توان به تغییر واگرا، جراحی با تفنگ ساچمه ای، و Parallel Inheritance Hierarchies اشاره کرد.
  <br>
  4. dispensables: دسته‌ای از bad smellها هستند که نشان دهنده کدهای غیر ضروری یا اضافی هستند. به عنوان مثال می توان به Dead Code، Speculative Generality و Duplicate Code اشاره کرد.
  <br>
  5. couplers: دسته‌ای از bad smellها هستند که نشان دهنده اتصال تنگاتنگ بین کلاس ها یا ماژول ها است و تغییر یا آزمایش کد را دشوار می کند. به عنوان مثال می توان به Feature Envy، Message Chains و Middle Man اشاره کرد.
  <br>
  سوال سوم: 1. dipensableها
  <br>
  2. استفاده از inline class، روش ادغام کلاس‌ها و Extract Subclass or Extract Interface
  <br>
  3. اگر انتظار دارید که کلاس تنبل در آینده مسئولیت ها یا عملکردهای بیشتری به دست آورد، ممکن است منطقی باشد که آن را به عنوان یک کلاس جداگانه نگه دارید. این امر می تواند گسترش و حفظ بنیان کد را در صورت بروز نیازهای جدید آسان تر کند. در حالت دیگر اگر کلاس تنبل مسئول یک concern یا concept خاص است، ممکن است جدا نگه داشتن آن مفید باشد، حتی اگر عملکرد زیادی نداشته باشد. این می تواند به حفظ تفکیک دقیق نگرانی ها کمک کند و کد را قابل درک تر کند. همچنین گاهی اوقات، یک کلاس تنبل ممکن است برای اهداف آزمایشی مفید باشد. به عنوان مثال، ممکن است هنگام نوشتن تست‌های واحد برای کلاس‌های دیگری که به آن وابسته هستند، mock کردن یا خرد کردن یک کلاس تنبل آسان‌تر باشد. در چنین مواردی، نگه داشتن کلاس تنبل می تواند تست پذیری و نگهداری را بهبود بخشد.
  
</div>
